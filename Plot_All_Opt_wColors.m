
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% script "Plot_All_Opt_wColors"
% ENME 610 - Engineering Optimization
% University of Maryland, College Park
% Group 1: David Smart, Luke Travisiano, Jason Morin
% AUV Optimization
%
%% Description:
%       Plots all of the optima generated by the various methods as
%       diffrent colors/markers in the normalized criterion space.
%
%% Instructions:
%       Verify that all of the following files exist before hitting 'Run':
%           'GRID_results.mat'
%           'ALL_results.mat'
%           'fmincon_results.mat'
%           'penalty_results.mat'
%           'penalty2_results.mat'
%           ('ALM_results.mat')
%           'fminimax_results.mat'
%           'Lq1_results.mat'
%           'Lq2_results.mat'
%           'LqInf_results.mat'
%           'EC_results.mat'
%           'EC2_results.mat'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% clean up
close all
clear
clc

[d_L, d_U, t_L, t_U, L_L, L_U, ~, ~] = set_Lims();

%% GRID
GRID_res = load('GRID_results.mat');
f1_s_GRID = GRID_res.f1_s;
f2_s_GRID = GRID_res.f2_s;

%% all "optima"
ALL_res = load('ALL_results.mat');
X = ALL_res.X;
f1 = ALL_res.f1;
f2 = ALL_res.f2;
f1_s = ALL_res.f1_s;
f2_s = ALL_res.f2_s;
Lq1 = ALL_res.Lq1;
Lq2 = ALL_res.Lq2;
LqInf = ALL_res.LqInf;

% select the Lq1 norm from the full set of all optima
[~, idx] = min(Lq1);
X_LQ1 = X(idx, :);
f1_LQ1 = f1(idx);
f2_LQ1 = f2(idx);
f1_s_LQ1 = f1_s(idx);
f2_s_LQ1 = f2_s(idx);

% select the Lq2 norm from the full set of all optima
[~, idx] = min(Lq2);
X_LQ2 = X(idx, :);
f1_LQ2 = f1(idx);
f2_LQ2 = f2(idx);
f1_s_LQ2 = f1_s(idx);
f2_s_LQ2 = f2_s(idx);

% select the LqInf norm from the full set of all optima
[~, idx] = min(LqInf);
X_LQinf = X(idx, :);
f1_LQinf = f1(idx);
f2_LQinf = f2(idx);
f1_s_LQinf = f1_s(idx);
f2_s_LQinf = f2_s(idx);

% extract good and bad values from all optima
f1_g    = min(f1);
f1_b    = max(f1);
f2_b    = min(f2);
f2_g    = max(f2);

%% fmincon
fmincon_res = load('fmincon_results.mat');
X_fmincon = fmincon_res.X;
f1_fmincon = fmincon_res.f1;
f2_fmincon = fmincon_res.f2;

% re-normalize according to full set of optima
for i = 1:max(size(f1_fmincon))
    f1_s_fmincon(i,:) = (f1_fmincon(i) - f1_g)/(f1_b - f1_g);
    f2_s_fmincon(i,:) = (f2_fmincon(i) - f2_g)/(f2_b - f2_g);
end

%% Penalty Method
penalty_res = load('penalty_results.mat');
X_penalty = penalty_res.X;
f1_penalty = penalty_res.f1;
f2_penalty = penalty_res.f2;

% re-normalize according to full set of optima
for i = 1:max(size(f1_penalty))
    f1_s_penalty(i,:) = (f1_penalty(i) - f1_g)/(f1_b - f1_g);
    f2_s_penalty(i,:) = (f2_penalty(i) - f2_g)/(f2_b - f2_g);
end

% second chosen start point
penalty2_res = load('penalty2_results.mat');
X_penalty2 = penalty2_res.X;
f1_penalty2 = penalty2_res.f1;
f2_penalty2 = penalty2_res.f2;

% re-normalize according to full set of optima
for i = 1:max(size(f1_penalty2))
    f1_s_penalty2(i,:) = (f1_penalty2(i) - f1_g)/(f1_b - f1_g);
    f2_s_penalty2(i,:) = (f2_penalty2(i) - f2_g)/(f2_b - f2_g);
end

% combine both sets of the penalty method results
X_penalty = [X_penalty; X_penalty2];
f1_penalty = [f1_penalty; f1_penalty2];
f2_penalty = [f2_penalty; f2_penalty2];
f1_s_penalty = [f1_s_penalty; f1_s_penalty2];
f2_s_penalty = [f2_s_penalty; f2_s_penalty2];

% %% Augmented Lagrangian Method (ALM)
% ALM_res = load('ALM_results.mat');
% X_ALM = ALM_res.X;
% f1_ALM = ALM_res.f1;
% f2_ALM = ALM_res.f2;
% 
% 
% for i = 1:max(size(f1_ALM))
%     f1_s_ALM(i,:) = (f1_ALM(i) - f1_g)/(f1_b - f1_g);
%     f2_s_ALM(i,:) = (f2_ALM(i) - f2_g)/(f2_b - f2_g);
% end


%% fminimax
fminimax_res = load('fminimax_results.mat');
X_fminimax = fminimax_res.X_opt;
f1_fminimax = fminimax_res.f1;
f2_fminimax = fminimax_res.f2;

% re-normalize according to full set of optima
for i = 1:max(size(f1_fminimax))
    f1_s_fminimax(i,:) = (f1_fminimax(i) - f1_g)/(f1_b - f1_g);
    f2_s_fminimax(i,:) = (f2_fminimax(i) - f2_g)/(f2_b - f2_g);
end

%% Global Criterion (Lq)
Lq1_res = load('Lq1_results.mat');
X_Lq1 = Lq1_res.X_opt;
f1_Lq1 = Lq1_res.f1;
f2_Lq1 = Lq1_res.f2;

% re-normalize according to full set of optima
for i = 1:max(size(f1_Lq1))
    f1_s_Lq1(i,:) = (f1_Lq1(i) - f1_g)/(f1_b - f1_g);
    f2_s_Lq1(i,:) = (f2_Lq1(i) - f2_g)/(f2_b - f2_g);
end

Lq2_res = load('Lq2_results.mat');
X_Lq2 = Lq2_res.X_opt;
f1_Lq2 = Lq2_res.f1;
f2_Lq2 = Lq2_res.f2;

% re-normalize according to full set of optima
for i = 1:max(size(f1_Lq2))
    f1_s_Lq2(i,:) = (f1_Lq2(i) - f1_g)/(f1_b - f1_g);
    f2_s_Lq2(i,:) = (f2_Lq2(i) - f2_g)/(f2_b - f2_g);
end

LqInf_res = load('LqInf_results.mat');
X_LqInf = LqInf_res.X_opt;
f1_LqInf = LqInf_res.f1;
f2_LqInf = LqInf_res.f2;

% re-normalize according to full set of optima
for i = 1:max(size(f1_LqInf))
    f1_s_LqInf(i,:) = (f1_LqInf(i) - f1_g)/(f1_b - f1_g);
    f2_s_LqInf(i,:) = (f2_LqInf(i) - f2_g)/(f2_b - f2_g);
end

% combine all results obtained by the Global Criterion method
X_Lq = [X_Lq1; X_Lq2; X_LqInf];
f1_Lq = [f1_Lq1; f1_Lq2; f1_LqInf];
f2_Lq = [f2_Lq1; f2_Lq2; f2_LqInf];
f1_s_Lq = [f1_s_Lq1; f1_s_Lq2; f1_s_LqInf];
f2_s_Lq = [f2_s_Lq1; f2_s_Lq2; f2_s_LqInf];

%% Epsilon Constrained (EC)
% optimizing for drag while constraining volume
EC_res = load('EC_results.mat');
X_EC = EC_res.X;
f1_EC = EC_res.f1;
f2_EC = EC_res.f2;

% re-normalize according to full set of optima
for i = 1:max(size(f1_EC))
    f1_s_EC(i,:) = (f1_EC(i) - f1_g)/(f1_b - f1_g);
    f2_s_EC(i,:) = (f2_EC(i) - f2_g)/(f2_b - f2_g);
end

% optimizing for volume, while constraining drag
EC2_res = load('EC2_results.mat');
X_EC2 = EC2_res.X;
f1_EC2 = EC2_res.f1;
f2_EC2 = EC2_res.f2;

% re-normalize according to full set of optima
for i = 1:max(size(f1_EC2))
    f1_s_EC2(i,:) = (f1_EC2(i) - f1_g)/(f1_b - f1_g);
    f2_s_EC2(i,:) = (f2_EC2(i) - f2_g)/(f2_b - f2_g);
end

% combine both sets of optima obtained by the epsilon constrained method
X_EC = [X_EC; X_EC2];
f1_EC = [f1_EC; f1_EC2];
f2_EC = [f2_EC; f2_EC2];
f1_s_EC = [f1_s_EC; f1_s_EC2];
f2_s_EC = [f2_s_EC; f2_s_EC2];

%% plot according to color and marker type
figure; hold on
plot(f1_s_GRID,       f2_s_GRID,        '.', 'color', [0.5, 0.5, 0.5])
plot(f1_s_EC,         f2_s_EC,          '.g')
plot(f1_s_penalty,    f2_s_penalty,     '.r')
plot(f1_s_fmincon,    f2_s_fmincon,     '.c')
% plot(f1_s_ALM,        f2_s_ALM, '.c')
plot(f1_s_fminimax,   f2_s_fminimax,    'ob', 'MarkerFaceColor','b')
plot(f1_s_Lq,         f2_s_Lq,          'ok')
plot(f1_s_LQ1,        f2_s_LQ1,         '*m')
plot(f1_s_LQ2,        f2_s_LQ2,         '*m')
plot(f1_s_LQinf,      f2_s_LQinf,       '*m')
legend('Grid','Epsilon Constrained', 'Penalty', 'fmincon', 'fminimax', 'Global Criterion', 'Gobal Criterion (2)')
title('Normalized Criterion Space')
xlabel('f1 - drag')
ylabel('f2 - volume')
axis([0, 1, 0, 1]);
axis on
% saveas(gcf,'AllOpt_wColor_NormalizedCriterionSpace.jpg')

%%