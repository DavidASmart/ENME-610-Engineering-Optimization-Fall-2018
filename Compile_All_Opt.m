
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% script "Compile_All_Opt"
% ENME 610 - Engineering Optimization
% University of Maryland, College Park
% Group 1: David Smart, Luke Travisiano, Jason Morin
% AUV Optimization
%
%% Description:
%       Combines all of the optima generated by the various methods into a 
%       single set which is saved as 'ALL_results.mat'.
%
%% Instructions:
%       Verify that all of the following files exist before hitting 'Run':
%           'fmincon_results.mat'
%           'penalty_results.mat'
%           'penalty2_results.mat'
%           ('ALM_results.mat')
%           'fminimax_results.mat'
%           'Lq1_results.mat'
%           'Lq2_results.mat'
%           'LqInf_results.mat'
%           'EC_results.mat'
%           'EC2_results.mat'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% clean up
close all
clear
clc

%% fmincon
fmincon_res = load('fmincon_results.mat');
X_fmincon = fmincon_res.X;
f1_fmincon = fmincon_res.f1;
f2_fmincon = fmincon_res.f2;

%% Penalty Method
penalty_res = load('penalty_results.mat');
X_penalty = penalty_res.X;
f1_penalty = penalty_res.f1;
f2_penalty = penalty_res.f2;

penalty2_res = load('penalty2_results.mat');
X_penalty2 = penalty2_res.X;
f1_penalty2 = penalty2_res.f1;
f2_penalty2 = penalty2_res.f2;

X_penalty = [X_penalty; X_penalty2];
f1_penalty = [f1_penalty; f1_penalty2];
f2_penalty = [f2_penalty; f2_penalty2];

%% Augmented Lagrangian Method (ALM)
ALM_res = load('ALM_results.mat');
X_ALM = ALM_res.X;
f1_ALM = ALM_res.f1;
f2_ALM = ALM_res.f2;

%% fminimax
fminimax_res = load('fminimax_results.mat');
X_fminimax = fminimax_res.X_opt;
f1_fminimax = fminimax_res.f1;
f2_fminimax = fminimax_res.f2;

%% Global Criterion (Lq)
Lq1_res = load('Lq1_results.mat');
X_Lq1 = Lq1_res.X_opt;
f1_Lq1 = Lq1_res.f1;
f2_Lq1 = Lq1_res.f2;

Lq2_res = load('Lq2_results.mat');
X_Lq2 = Lq2_res.X_opt;
f1_Lq2 = Lq2_res.f1;
f2_Lq2 = Lq2_res.f2;

LqInf_res = load('LqInf_results.mat');
X_LqInf = LqInf_res.X_opt;
f1_LqInf = LqInf_res.f1;
f2_LqInf = LqInf_res.f2;

X_Lq = [X_Lq1; X_Lq2; X_LqInf];
f1_Lq = [f1_Lq1; f1_Lq2; f1_LqInf];
f2_Lq = [f2_Lq1; f2_Lq2; f2_LqInf];

%% Epsilon Constrained (EC)
EC_res = load('EC_results.mat');
X_EC = EC_res.X;
f1_EC = EC_res.f1;
f2_EC = EC_res.f2;

EC2_res = load('EC2_results.mat');
X_EC2 = EC2_res.X;
f1_EC2 = EC2_res.f1;
f2_EC2 = EC2_res.f2;

X_EC = [X_EC; X_EC2];
f1_EC = [f1_EC; f1_EC2];
f2_EC = [f2_EC; f2_EC2];

%% compile ALL

X = [X_fmincon; X_penalty;  X_fminimax; X_Lq; X_EC];
f1 = [f1_fmincon; f1_penalty;  f1_fminimax; f1_Lq; f1_EC];
f2 = [f2_fmincon; f2_penalty;  f2_fminimax; f2_Lq; f2_EC];

f1_g    = min(f1);
f1_b    = max(f1);
f2_b    = min(f2);
f2_g    = max(f2);

% normalize
for i = 1:max(size(f1))
    % scalled values
    f1_s(i,:) = (f1(i) - f1_g)/(f1_b - f1_g);
    f2_s(i,:) = (f2(i) - f2_g)/(f2_b - f2_g);

    % multi-objective Lq-method
    Lq1(i,:) = sum([f1_s(i), f2_s(i)]);
    Lq2(i,:) = sqrt(sumsqr([f1_s(i), f2_s(i)]));
    LqInf(i,:) = max([f1_s(i), f2_s(i)]);
end


%% save
save('ALL_results.mat', 'X', 'f1', 'f2', 'f1_s', 'f2_s', 'Lq1', 'Lq2', 'LqInf');

%%